package org.usfirst.frc1884.RobotCode2013.commands;
import com.sun.squawk.util.MathUtils;
import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc1884.RobotCode2013.Robot;
public class  SafeAutonomousCommand extends Command {
    public static final double GYRO_DAMPING = 0.3;
    
    // Major states
    public static final int SPINNING_UP_WHEELS = -1,
                            SHOOTING_ORIGINAL_THREE_FRISBEES = 0,
                            MOVING_BACK_TO_CENTER_LINE = 1,
                            PICKING_UP_CENTERLINE_FRISBEES = 2,
                            END = 9000;
    public int majorState = SPINNING_UP_WHEELS;
    
    // Spinning up wheels states
    public long timeSpinUpStarted = -1;
    
    // Original three frisbees states
    public int frisbeesLeft = 3;
    public boolean firingPistonExtended = false;
    public long timeOfLastPistonFire = 0;
    
    // Moving back to center line state
    public boolean hasSeenCenterLine = false;
    public static long centerLineFrisbees;
    public static double backWardsAngle;
    public static void setFrisbeeSideSteppingAngle(long centerLineFrisbees) {
        SafeAutonomousCommand.centerLineFrisbees = centerLineFrisbees;
        double lengthToDodge = (centerLineFrisbees + 1.0) / 2.0 * 11 - 94.0 / 2.0 - 24 / 2.0; // inches
        double verticalLengthOfTravel = 108 + 31.0 / 2.0;
        backWardsAngle = MathUtils.atan(lengthToDodge / verticalLengthOfTravel);
    }
    
    // Picking up centerline frisbees
    public long timeStartedStrafing = -1;
    
    public SafeAutonomousCommand() {
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);
	
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.chassis);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.shooter);
        requires(Robot.feeder);
        requires(Robot.storageBox);
    }
    // Called just before this Command runs the first time
    protected void initialize() {
    }
    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
        long currentTime = System.currentTimeMillis();
        double gyroValue = Robot.other.getGyroValue();
        if(majorState == SPINNING_UP_WHEELS) {
            if(timeSpinUpStarted == -1) {
                System.out.println("spinning up wheels");
                timeSpinUpStarted = System.currentTimeMillis();
                Robot.shooter.setShootingMotors(0.8, 1.0);
            } else if(currentTime > timeSpinUpStarted + 3000) {
                majorState = SHOOTING_ORIGINAL_THREE_FRISBEES;
            }
        } else if(majorState == SHOOTING_ORIGINAL_THREE_FRISBEES) {
            if(!firingPistonExtended) {
                if(currentTime > timeOfLastPistonFire + 1000) {
                    timeOfLastPistonFire = currentTime;
                    Robot.storageBox.extendFiringPiston();
                    frisbeesLeft--;
                    firingPistonExtended = true;
                }
            } else {
                if(currentTime > timeOfLastPistonFire + 300) {
                    timeOfLastPistonFire = currentTime;
                    Robot.storageBox.retractFiringPiston();
                    if(frisbeesLeft <= 0) {
                        majorState = END; //MOVING_BACK_TO_CENTER_LINE;
                    }
                    firingPistonExtended = false;
                }
            }
        } else if(majorState == MOVING_BACK_TO_CENTER_LINE) {
            Robot.shooter.setShootingMotors(0.0, 0.0);
            if(Robot.feeder.getLowerSwitch()) {
                Robot.feeder.armOff();
            } else {
                Robot.feeder.extendArm();
            }
            
            if(Robot.chassis.getBackLightSensor()) {
                hasSeenCenterLine = true;
            }
            if(Robot.chassis.getFrontLightSensor()) {
                majorState = PICKING_UP_CENTERLINE_FRISBEES;
            }
            
            if(hasSeenCenterLine) {
                Robot.chassis.driveMecanumNormalized(0.2, 0, 0);
            } else {
                Robot.chassis.driveMecanumNormalized(-Math.cos(backWardsAngle), -Math.sin(backWardsAngle), -gyroValue * GYRO_DAMPING);
            }
        } else if(majorState == PICKING_UP_CENTERLINE_FRISBEES) {
            Robot.shooter.setShootingMotors(0.8, 1.0);
            Robot.feeder.setFeederIntakeSpeed(1.0);
            
            double forwardsValue = 0.0;
            if(Robot.chassis.getFrontLightSensor()) {
                forwardsValue = 0.3;
            }
            if(Robot.chassis.getBackLightSensor()) {
                forwardsValue = -0.3;
            }
            
            if(timeStartedStrafing == -1) {
                timeStartedStrafing = currentTime;
            }
            if(currentTime <= timeStartedStrafing + 4000) {
                Robot.chassis.driveMecanumNormalized(forwardsValue, 0.5, -gyroValue * GYRO_DAMPING);
                if(!firingPistonExtended) {
                    if(currentTime > timeOfLastPistonFire + 300) {
                        timeOfLastPistonFire = currentTime;
                        Robot.storageBox.extendFiringPiston();
                        firingPistonExtended = true;
                    }
                } else {
                    if(currentTime > timeOfLastPistonFire + 300) {
                        timeOfLastPistonFire = currentTime;
                        Robot.storageBox.retractFiringPiston();
                        firingPistonExtended = false;
                    }
                }
            }
        } else if(majorState == END) {
            Robot.shooter.setShootingMotors(0.0, 0.0);
        }
    }
    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return false;
    }
    // Called once after isFinished returns true
    protected void end() {
    }
    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    }
}
